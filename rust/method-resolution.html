<h1 id="rust-method-resolution">Rust method resolution</h1>
<p>The Rust reference counting <code>Rc</code> type <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-Clone">implements the <code>Clone</code> trait</a>. Every call to <code>clone</code> increments the strong count for the <code>Rc</code> instance. This allows us to count how many times <code>Rc::clone</code> has been called.</p>
<p>The Rust shared reference type <code>&amp;T</code> also <a href="https://doc.rust-lang.org/std/primitive.reference.html#trait-implementations-1">implements the <code>Clone</code> trait</a>. (<code>T</code> can be any type including <code>Rc</code>). Note that the documentation for <code>&amp;T</code> points out that &quot;this will not defer to Tâ€™s Clone implementation&quot;.</p>
<p>Consider this code:</p>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> std::rc::Rc;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// A new `Rc` has a count of 1.</span>
    <span class="hljs-keyword">let</span> a = Rc::new(());
    <span class="hljs-built_in">assert!</span>(Rc::strong_count(&amp;a) == <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Calling `a.clone()` uses the `Rc::clone` implementation and increments the count to 2.</span>
    <span class="hljs-keyword">let</span> b = a.clone();
    <span class="hljs-built_in">assert!</span>(Rc::strong_count(&amp;a) == <span class="hljs-number">2</span>);

    <span class="hljs-comment">// Calling `(&amp;&amp;a).clone()` uses the `&amp;T::clone` implementation and the count is unchanged.</span>
    <span class="hljs-keyword">let</span> c = (&amp;&amp;a).clone();
    <span class="hljs-built_in">assert!</span>(Rc::strong_count(&amp;a) == <span class="hljs-number">2</span>);

    <span class="hljs-comment">// What happens when we call `(&amp;a).clone()`?</span>
    <span class="hljs-keyword">let</span> d = (&amp;a).clone();
    dbg!(Rc::strong_count(&amp;a));
}
</code></pre>
<p>The receiver for a method is the expression before the dot. For example, for <code>a.clone()</code> the receiver is <code>a</code>.</p>
<p>When assigning to <code>b</code> the receiver <code>a</code> has type <code>Rc&lt;()&gt;</code>. The reference count increases, indicating that we called <code>Rc::clone</code>.</p>
<p>When assigning to <code>c</code> the receiver <code>&amp;&amp;a</code> has type <code>&amp;&amp;Rc&lt;()&gt;</code>. The reference count does not increase, indicating that we did not call <code>Rc::clone</code>. We called <code>&amp;T::clone</code> instead, and, as we know, that does not use <code>Rc</code>&#39;s Clone implementation.</p>
<p>The question is what happens when we call <code>(&amp;a).clone()</code>?
The receiver has type <code>&amp;Rc&lt;()&gt;</code>. This type does not match <code>Rc&lt;T&gt;</code>. It does match <code>&amp;T</code>, where <code>T</code> is <code>Rc&lt;()&gt;</code>.</p>
<p>The intuitive answer is that <code>(&amp;a).clone()</code> calls the <code>&amp;T::clone</code> implementation, the count remains unchanged, and the code prints <code>Rc::strong_count(&amp;a) = 2</code>.</p>
<p>So it might seem surprising that running the code prints <code>Rc::strong_count(&amp;a) = 3</code>.</p>
<hr>
<p>When you look at a Rust <code>impl</code> block, such as <code>impl&lt;T&gt; Rc&lt;T&gt;</code>, it appears to implement methods for a single (possibly generic) type (<code>Rc&lt;T&gt;</code>), and the different forms for methods (<code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code>) just indicate how the receiver is borrowed.</p>
<p>However the <code>self</code> argument to the method plays a more significant part than expected.</p>
<p>An <code>impl</code> block contains methods for multiple types that are <a href="https://doc.rust-lang.org/reference/items/associated-items.html#methods">&quot;associated&quot; with the named &quot;implementing type&quot;</a>.</p>
<p>The <code>Clone</code> trait provides the method signature <code>fn clone(&amp;self) -&gt; Self</code>, shorthand for <code>fn clone(self: &amp;Self) -&gt; Self</code></p>
<p>When <code>Self</code> is <code>Rc</code>:</p>
<pre><code class="lang-rust">impl <span class="hljs-type">Clone</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Rc</span>&lt;T&gt; {
    fn clone(self: &amp;<span class="hljs-type">Rc</span>&lt;T&gt;) -&gt; <span class="hljs-type">Rc</span>&lt;T&gt; <span class="hljs-meta">{...}</span>
}
</code></pre>
<p>This implements a <code>clone</code> method that matches the type <code>&amp;Rc&lt;T&gt;</code>. So <code>Rc&lt;T&gt;::clone</code> gets called when the receiver is <code>&amp;Rc&lt;T&gt;</code>, which includes <code>&amp;Rc&lt;()&gt;</code>.</p>
<p>Similarly, <code>impl&lt;T&gt; Clone for &amp;T</code> implements a <code>clone</code> method matching the generic type <code>&amp;&amp;T</code> which includes <code>&amp;&amp;Rc&lt;T&gt;</code>. So <code>`&amp;T::clone</code> gets called when the receiver is <code>&amp;&amp;T</code>, which includes <code>&amp;&amp;Rc&lt;()&gt;</code>.</p>
<p>There is no <code>clone</code> method that matches the type <code>Rc&lt;T&gt;</code>.</p>
<p>The question is not why does <code>&amp;a.clone()</code> call <code>Rc::clone</code>. The question is why does <code>a.clone()</code> call <code>Rc::clone</code>?</p>
<hr>
<p><code>a.clone()</code> works because Rust uses a <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">consistent procedure to match methods against a chain of types</a> derived from the receiver. The chain starts <code>Rc&lt;()&gt;</code>, <code>&amp;Rc&lt;()&gt;</code>, <code>&amp;mut Rc&lt;()&gt;</code>, and then continues through any <code>Deref</code> trait. For each type in the chain, Rust looks for a method that matches.</p>
<p>For <code>a.clone()</code> the first candidate, <code>Rc&lt;()&gt;</code>, does not match any <code>clone</code> method. The second candidate, <code>&amp;Rc</code>, does: the <code>Rc::clone</code> implementation.  So Rust creates a reference to the receiver, and passes that to the <code>Rc::clone</code> implementation, incrementing the count to 3.</p>
<p>For another example of this behaviour using non-standard-library types, see <a href="https://users.rust-lang.org/t/when-will-auto-deref-happen-for-receiver-in-method-call/43209">https://users.rust-lang.org/t/when-will-auto-deref-happen-for-receiver-in-method-call/43209</a></p>
